#!/bin/sh
#
# Usage: ./build-zsh-5.8-static [-m ARCH] [-c CPU] [-i IMAGE]
#
# Type `./build-zsh-5.8-static -h` for help and see
# https://github.com/romkatv/zsh-bin for full documentation.

set -ue

usage="$(cat <<\END
Usage: ./build-zsh-5.8-static [-m ARCH] [-c CPU] [-i IMAGE]

Creates an archive containing statically-linked, hermetic,
relocatable Zsh 5.8. Installation of Zsh from the archive
doesn't require libc, terminfo, ncurses or root access.
As long as the target machine has a compatible CPU and
Linux kernel, it'll work.

Options:

  -m ARCH   `uname -m` from the target machine; defaults to `uname -m`
            from the local machine
  -c CPU    generate machine instructions for CPU of this type; this
            value gets passed as -march to gcc; inferred from ARCH
            if not set explicitly
  -i IMAGE  docker image used for building zsh; inferred from ARCH
            if not set explicitly
END
)"

build="$(cat <<\END
case "$ZSH_BIN_KERNEL" in
  linux)
    apk update
    apk add          \
      autoconf       \
      bash           \
      binutils       \
      g++            \
      gcc            \
      gdbm-dev       \
      groff          \
      make           \
      man            \
      musl-dev       \
      ncurses        \
      ncurses-dev    \
      ncurses-static \
      pcre-dev       \
      util-linux     \
      tar
    cd
    wget https://gitlab.com/fbb-git/icmake/-/archive/9.03.01/icmake-9.03.01.tar.gz
    tar -xzf icmake-9.03.01.tar.gz
    cd icmake-9.03.01/icmake
    ./icm_prepare /
    ./icm_bootstrap x
    ./icm_install all

    cd
    wget https://gitlab.com/fbb-git/yodl/-/archive/4.02.01/yodl-4.02.01.tar.gz
    tar -xzf yodl-4.02.01.tar.gz
    cd yodl-4.02.01/yodl
    mkdir ../fake-bin
    touch ../fake-bin/tput
    chmod +x ../fake-bin/tput
    PATH="$PWD/../fake-bin:$PATH" ./build programs
    PATH="$PWD/../fake-bin:$PATH" ./build macros
    PATH="$PWD/../fake-bin:$PATH" ./build install programs
    PATH="$PWD/../fake-bin:$PATH" ./build install macros
  ;;
  freebsd)
    pkg install -y \
      autoconf     \
      binutils     \
      gcc          \
      groff        \
      ncurses      \
      pcre         \
      yodl
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"
    exit 1
  ;;
esac

cd
wget https://github.com/zsh-users/zsh/archive/zsh-5.8.tar.gz
tar -xzf zsh-5.8.tar.gz
cd zsh-zsh-5.8

name=zsh-5.8-"$ZSH_BIN_KERNEL"-"$ZSH_BIN_ARCH"-static

./Util/preconfig
./configure                             \
  --prefix=/"$name"                     \
  --disable-etcdir                      \
  --disable-zshenv                      \
  --disable-zshrc                       \
  --disable-zlogin                      \
  --disable-zprofile                    \
  --disable-zlogout                     \
  --disable-site-fndir                  \
  --disable-site-scriptdir              \
  --enable-cap                          \
  --with-tcsetpgrp                      \
  --disable-dynamic                     \
  --enable-ldflags=-static              \
  --enable-cflags=-march="$ZSH_BIN_CPU" \
  --host="$ZSH_BIN_ARCH"                \
  --enable-custom-patchlevel="$name"

sed_i() {
  [ $# = 2 ]
  local file=$2
  sed "$@" >"$file".tmp
  mv -- "$file".tmp "$file"
}

sed_i 's/link=no/link=static/' config.modules

if [ "$ZSH_BIN_KERNEL" != linux ]; then
  sed_i 's/attr.mdd link=static/attr.mdd link=no/' config.modules
  sed_i 's/db_gdbm.mdd link=static/db_gdbm.mdd link=no/' config.modules
fi

sed_i '46i\
#include <math.h>' Src/params.c
sed_i 's|mv -f zshpaths.h.tmp zshpaths.h|cp -f ../zshpaths.h ./|' Src/zsh.mdd

cat >zshpaths.h <<-\END
	#define MODULE_DIR "/dev/null"

	#define SCRIPT_DIR_TAG ":iLWDLaG9dUlsxzEQp10k:script:"
	#define FPATH_DIR_TAG ":iLWDLaG9dUlsxzEQp10k:fpath:"
	#define TERMINFO_DIR_TAG ":iLWDLaG9dUlsxzEQp10k:terminfo:"

	extern volatile char tagged_script_dir[sizeof(SCRIPT_DIR_TAG) + 4096];
	extern volatile char tagged_fpath_dir[sizeof(FPATH_DIR_TAG) + 4096];
	extern volatile char tagged_terminfo_dir[sizeof(TERMINFO_DIR_TAG) + 4096];

	#define SCRIPT_DIR ((const char *)(tagged_script_dir + sizeof(SCRIPT_DIR_TAG) - 1))
	#define FPATH_DIR ((const char *)(tagged_fpath_dir + sizeof(FPATH_DIR_TAG) - 1))
	#define TERMINFO_DIR ((const char *)(tagged_terminfo_dir + sizeof(TERMINFO_DIR_TAG) - 1))

	extern int tgetent_with_env(char *, char *);
	END

sed_i 's/tgetent/tgetent_with_env/g' Src/init.c

cat >>Src/init.c <<-\END
	volatile char tagged_script_dir[sizeof(SCRIPT_DIR_TAG) + 4096] = {
	  SCRIPT_DIR_TAG "/usr/share/zsh/5.8/scripts"
	};
	volatile char tagged_fpath_dir[sizeof(FPATH_DIR_TAG) + 4096] = {
	  FPATH_DIR_TAG "/usr/share/zsh/5.8/functions"
	};
	volatile char tagged_terminfo_dir[sizeof(TERMINFO_DIR_TAG) + 4096] = {
	  TERMINFO_DIR_TAG "/usr/share/terminfo"
	};

	extern int tgetent_with_env(char *termbuf, char *term) {
	  const char *orig;
	  const char *patched;
	  int res;
	  orig = getenv("TERMINFO_DIRS");
	  patched = orig ? tricat(orig, ":", TERMINFO_DIR) : TERMINFO_DIR;
	  setenv("TERMINFO_DIRS", patched, 1);  /* ignore ENOMEM */
	  res = tgetent(termbuf, term);
	  if (orig) {
	    zsfree((char *)patched);
	    setenv("TERMINFO_DIRS", orig, 1);  /* ignore ENOMEM */
	  } else {
	    unsetenv("TERMINFO_DIRS");
	  }
	  return res;
	}
	END

cpus=$(getconf _NPROCESSORS_ONLN) || cpus=$(sysctl -n hw.ncpu) || cpus=8

make -j "$cpus" install
strip -s /"$name"/bin/zsh
rm /"$name"/bin/zsh-5.8

if [ -d /usr/share/terminfo ]; then
  cp -r /usr/share/terminfo /"$name"/share/
else
  cp /usr/local/share/misc/terminfo.db /"$name"/share/
fi

cat >/"$name"/share/zsh/5.8/scripts/relocate <<-\END
	#!/bin/sh

	set -ue

	if [ $# -gt 2 ]; then
	  >&2 echo 'usage: relocate [/path/to/root-dir] [/path/to/zsh]'
	  exit 1
	fi

	if [ $# -ge 1 ]; then
	  root_dir=$(readlink -f -- "$1")
	else
	  self_dir=$(dirname -- "$0")
	  root_dir=$(readlink -f -- "$self_dir"/../../../..)
	fi

	if [ $# -ge 2 ]; then
	  zsh=$2
	else
	  self_dir=$(dirname -- "$0")
	  zsh="$self_dir"/../../../../bin/zsh
	fi

	if [ ! -x "$zsh" ]; then
	  >&2 echo "[error] not an executable file: $zsh"
	  exit 1
	fi

	root_dir="${root_dir%/}/"

	# 4096 minus 23 for "share/zsh/5.8/functions"
	if [ ${#root_dir} -gt 4073 ]; then
	  >&2 echo "[error] directory name too long: $root_dir"
	  exit 1
	fi

	magic=iLWDLaG9dUlsxzEQp10k

	if [ -z "${root_dir##*$magic*}" ]; then
	  >&2 echo "[error] cannot relocate to this directory: $root_dir"
	  exit 1
	fi

	bin=$(LC_ALL=C tr -c '[:alnum:]:' ' ' <"$zsh")
	cp -pf -- "$zsh" "$zsh".tmp

	patch() {
	  local prefix="${bin%:$magic:$1:*}"
	  if [ "$prefix" = "$bin" ]; then
	    >&2 echo "[error] not a relocatable zsh binary: $zsh"
	    exit 1
	  fi
	  prefix="$prefix:$magic:$1:"
	  local dir="${root_dir}$2"
	  local err
	  if ! err=$(dd if=/dev/zero of="$zsh".tmp bs=1 seek=${#prefix} count=4096 conv=notrunc 2>&1); then
	    >&2 printf '%s\n' "$err"
	    exit 1
	  fi
	  if ! err=$(printf '%s' "$dir" |
	               dd of="$zsh".tmp bs=1 seek=${#prefix} count=${#dir} conv=notrunc 2>&1); then
	    >&2 printf '%s\n' "$err"
	    exit 1
	  fi
	}

	patch script   share/zsh/5.8/scripts
	patch fpath    share/zsh/5.8/functions
	patch terminfo share/terminfo

	if ! fpath=$("$zsh".tmp -c 'print -r -- $fpath[1]') ||
	   [ "${fpath#$root_dir}" = "$fpath" ]; then
	  >&2 echo "[error] failed to relocate zsh"
	  exit 1
	fi

	mv -f -- "$zsh".tmp "$zsh"
	END

chmod +x /"$name"/share/zsh/5.8/scripts/relocate

/"$name"/share/zsh/5.8/scripts/relocate
/"$name"/bin/zsh -ec 'zmodload zsh/zselect; autoload -Uz add-zsh-hook; add-zsh-hook precmd x'
/"$name"/share/zsh/5.8/scripts/relocate /usr

case "$ZSH_BIN_KERNEL" in
  linux)   deref=--hard-dereference;;
  freebsd) deref=;;
  *) >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"; exit 1;;
esac

tar -C / $deref -pczf /out/tmp."$name".tar.gz "$name"
mv -f -- /out/tmp."$name".tar.gz /out/"$name".tar.gz

case "$ZSH_BIN_KERNEL" in
  linux)   dir=.;;
  freebsd) dir=/out;;
  *) >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"; exit 1;;
esac

cat >&2 <<-END
	-------------------------------------------------
	SUCCESS: created $dir/$name.tar.gz.

	This archive contains statically-linked, hermetic,
	relocatable Zsh 5.8. Installation of Zsh from the archive
	doesn't require libc, terminfo, ncurses or root access.
	As long as the target machine has a compatible CPU and
	Linux kernel, it'll work.

	To install Zsh from the archive, copy it to the target
	machine's home directory and run:

    cd
	  rm -rf ~/.zsh-bin ~/$name
	  tar -xzf ~/$name.tar.gz
	  mv $name ~/.zsh-bin
	  ~/.zsh-bin/share/zsh/5.8/scripts/relocate
	  rm ~/$name.tar.gz

	Now you can invoke ~/.zsh-bin/bin/zsh and it'll just work.
	You'll probably want to add ~/.zsh-bin/bin to PATH for
	convenience.

	If you move or rename ~/.zsh-bin, you'll need to call
	share/zsh/5.8/scripts/relocate/relocate afterwards. See the
	last line in the instructions above.
	END
END
)"

arch=
cpu=
image=

while getopts ':m:c:i:h' opt "$@"; do
  case "$opt" in
    m)  arch=$OPTARG;;
    c)  cpu=$OPTARG;;
    i)  image=$OPTARG;;
    h)  printf '%s\n' "$usage"; exit;;
    \?) >&2 echo "[error] invalid option: $OPTARG"           ; exit 1;;
    :)  >&2 echo "[error] missing required argument: $OPTARG"; exit 1;;
    *)  >&2 echo "[internal error] unhandled option: $opt"   ; exit 1;;
  esac
done

if [ "$OPTIND" -le $# ]; then
  >&2 echo "[error] unexpected positional argument"
  return 1
fi

if [ -z "$arch" ]; then
  arch=$(uname -m)
  arch=$(printf '%s' "$arch" | tr '[A-Z]' '[a-z]')
fi

if [ -z "$cpu" ]; then
  case "$arch" in
    armv7l)         cpu=armv7;;
    aarch64)        cpu=armv8-a;;
    x86_64|amd64)   cpu=x86-64;;
    i386|i586|i686) cpu=$arch;;
    *)
      >&2 echo '[error] unable to infer target CPU architecture'
      >&2 echo 'Please specify explicitly with `-c CPU`.'
      exit 1
    ;;
  esac
fi

kernel=$(uname -s)
kernel=$(printf '%s' "$kernel" | tr '[A-Z]' '[a-z]')

case "$kernel" in
  linux)
    if [ -z "$image" ]; then
      case "$arch" in
        x86_64)         image=alpine:3.9.5;;
        i386|i586|i686) image=i386/alpine:3.9.5;;
        armv7l)         image=arm32v7/alpine:3.9.5;;
        aarch64)        image=arm64v8/alpine:3.9.5;;
        *)
          >&2 echo '[error] unable to infer docker image'
          >&2 echo 'Please specify explicitly with `-i IMAGE`.'
          exit 1
        ;;
      esac
    fi
    if ! command -v docker >/dev/null 2>&1; then
      >&2 echo '[error] docker not found; please install and retry'
      exit 1
    fi
  ;;
  freebsd)
    if [ -n "$image" ]; then
      >&2 echo '[error] docker image (-i) is not supported on freebsd'
      exit 1
    fi
  ;;
  *)
    >&2 echo '[error] unsupported kernel, sorry!'
    exit 1
  ;;
esac

>&2 echo "Building zsh..."
>&2 echo ""
[ -n "$image" ] && >&2 echo "  IMAGE=$image"
>&2 echo "  KERNEL=$kernel"
>&2 echo "  ARCH=$arch"
>&2 echo "  CPU=$cpu"

case "$kernel" in
  linux)
    docker run                    \
      -e ZSH_BIN_KERNEL="$kernel" \
      -e ZSH_BIN_ARCH="$arch"     \
      -e ZSH_BIN_CPU="$cpu"       \
      -v "$PWD":/out              \
      --tty                       \
      --rm                        \
      -- "$image" /bin/sh -uexc "$build"
  ;;
  freebsd)
    rm -rf /out
    mkdir /out
    ZSH_BIN_KERNEL="$kernel" ZSH_BIN_ARCH="$arch" ZSH_BIN_CPU="$cpu" \
      /bin/sh -uexc "$build"
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $kernel";
    exit 1
  ;;
esac
