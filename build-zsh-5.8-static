#!/bin/sh
#
# Usage: ./build-zsh-5.8 [-m ARCH] [-c CPU] [-i IMAGE]
#
# Type `./build-zsh-5.8 -h` for help and see
# https://github.com/romkatv/zsh-bin for full documentation.

set -ue

usage="$(cat <<\END
Usage: ./build-zsh-5.8 [-m ARCH] [-c CPU] [-i IMAGE]

Creates an archive containing statically-linked, hermetic,
relocatable Zsh 5.8. Installation of Zsh from the archive
doesn't require libc, terminfo, ncurses or root access.
As long as the target machine has a compatible CPU and
Linux kernel, it'll work.

Options:

  -m ARCH   `uname -m` from the target machine; defaults to `uname -m`
            from the local machine
  -c CPU    generate machine instructions for CPU of this type; this
            value gets passed as -march to gcc; inferred from ARCH
            if not set explicitly
  -i IMAGE  docker image used for building zsh; inferred from ARCH
            if not set explicitly
END
)"

build="$(cat <<\END
outdir=$(pwd)
if command -v mktemp >/dev/null 2>&1; then
  workdir=$(mktemp -d "${TMPDIR:-/tmp}"/zsh-bin.XXXXXXXXXX)
else
  workdir="${TMPDIR:-/tmp}/zsh-bin.$$"
  mkdir -- "$workdir"
fi
workdir=$(readlink -f -- "$workdir")
cleanup() {
  cd /
  rm -rf -- "$workdir"
}
trap cleanup INT QUIT TERM EXIT ILL PIPE

libiconv_version=1.16
icmake_version=9.03.01
yodl_version=4.02.01
libiconv_url=https://ftp.gnu.org/pub/gnu/libiconv/libiconv-$libiconv_version.tar.gz
icmake_url=https://gitlab.com/fbb-git/icmake/-/archive/$icmake_version/icmake-$icmake_version.tar.gz
yodl_url=https://gitlab.com/fbb-git/yodl/-/archive/$yodl_version/yodl-$yodl_version.tar.gz
zsh_url1=https://github.com/zsh-users/zsh/archive/zsh-5.8.tar.gz
zsh_url2=https://codeload.github.com/zsh-users/zsh/tar.gz/zsh-5.8

cpus=$(getconf _NPROCESSORS_ONLN) || cpus=$(sysctl -n hw.ncpu) || cpus=8

case "$ZSH_BIN_KERNEL" in
  linux)
    apk update
    apk add          \
      autoconf       \
      bash           \
      binutils       \
      file           \
      g++            \
      gcc            \
      gdbm-dev       \
      groff          \
      make           \
      man            \
      musl-dev       \
      ncurses        \
      ncurses-dev    \
      ncurses-static \
      pcre-dev       \
      tar            \
      util-linux

      cd -- "$workdir"
      wget -- "$libiconv_url"
      tar -xzf libiconv-"$libiconv_version".tar.gz
      cd libiconv-"$libiconv_version"
      ./configure                     \
        --prefix=/usr                 \
        --disable-dependency-tracking \
        --enable-static               \
        --disable-shared              \
        --enable-extra-encodings      \
        --disable-rpath               \
        --enable-relocatable
      make -j "$cpus" install
  ;;
  freebsd)
    pkg install -y \
      autoconf     \
      binutils     \
      gcc          \
      groff        \
      libiconv     \
      ncurses      \
      pcre         \
      yodl
  ;;
  msys*|mingw*)
    pacman -Sy --noconfirm \
      autoconf             \
      binutils             \
      gcc                  \
      groff                \
      libgdbm-devel        \
      libiconv-devel       \
      make                 \
      man                  \
      ncurses-devel        \
      pcre-devel           \
      yodl
  ;;
  cygwin*)
    for cmd in autoconf bash colcrt gcc g++ groff ld make tar wget; do
      if ! command -v "$cmd" >/dev/null 2>&1; then
        >&2 echo "[error] command not found: $cmd"
        exit 1
      fi
    done
    for file in /usr/lib/libiconv.a /usr/lib/libncursesw.a /usr/share/terminfo; do
      if [ ! -e "$file" ]; then
        >&2 echo "[error] not found: $file"
        exit 1
      fi
    done
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"
    exit 1
  ;;
esac

if ! command -v yodl >/dev/null 2>&1; then
  if ! command -v icmake >/dev/null 2>&1; then
    cd -- "$workdir"
    wget -- "$icmake_url"
    tar -xzf icmake-"$icmake_version".tar.gz
    cd icmake-"$icmake_version"/icmake
    ./icm_prepare /
    ./icm_bootstrap x
    ./icm_install all
  fi

  cd -- "$workdir"
  wget -- "$yodl_url"
  tar -xzf yodl-"$yodl_version".tar.gz
  cd yodl-"$yodl_version"/yodl
  mkdir ../fake-bin
  touch ../fake-bin/tput
  chmod +x ../fake-bin/tput
  PATH="$workdir/yodl-$yodl_version/fake-bin:$PATH" ./build programs
  PATH="$workdir/yodl-$yodl_version/fake-bin:$PATH" ./build macros
  PATH="$workdir/yodl-$yodl_version/fake-bin:$PATH" ./build install programs
  PATH="$workdir/yodl-$yodl_version/fake-bin:$PATH" ./build install macros
fi

cd -- "$workdir"
if ! wget -O zsh-5.8.tar.gz -- "$zsh_url1"; then
  wget -O zsh-5.8.tar.gz "$zsh_url2"
fi
tar -xzf zsh-5.8.tar.gz
cd zsh-zsh-5.8

name=zsh-5.8-"$ZSH_BIN_KERNEL"-"$ZSH_BIN_ARCH"

./Util/preconfig
./configure                             \
  --prefix=/"$name"                     \
  --disable-etcdir                      \
  --disable-zshenv                      \
  --disable-zshrc                       \
  --disable-zlogin                      \
  --disable-zprofile                    \
  --disable-zlogout                     \
  --disable-site-fndir                  \
  --disable-site-scriptdir              \
  --enable-cap                          \
  --with-tcsetpgrp                      \
  --disable-dynamic                     \
  --enable-ldflags=-static              \
  --enable-cflags=-march="$ZSH_BIN_CPU" \
  --host="$ZSH_BIN_ARCH"                \
  --enable-custom-patchlevel="$name"

sed_i() {
  [ $# = 2 ]
  local file=$2
  sed "$@" >"$file".tmp
  mv -- "$file".tmp "$file"
}

sed_i 's/link=no/link=static/' config.modules

case "$ZSH_BIN_KERNEL" in
  linux|msys*|mingw*);;
  freebsd)
    sed_i 's/attr.mdd link=static/attr.mdd link=no/' config.modules
    sed_i 's/db_gdbm.mdd link=static/db_gdbm.mdd link=no/' config.modules
  ;;
  cygwin*)
    sed_i 's/db_gdbm.mdd link=static/db_gdbm.mdd link=no/' config.modules
    sed_i 's/pcre.mdd link=static/pcre.mdd link=no/' config.modules
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"
    exit 1
  ;;
esac

magic=iLWDLaG9dUlsxzEQp10k

sed_i '46i\
#include <math.h>' Src/params.c
sed_i 's|mv -f zshpaths.h.tmp zshpaths.h|cp -f ../zshpaths.h ./|' Src/zsh.mdd
sed_i 's/\(\$(LN_S).*\);/( cd -- $(DESTDIR)$(runhelpdir) \&\& \1; );/' Doc/Makefile.in

sed_i 's/tgetent/tgetent_with_env/g' Src/init.c

cat >>Src/init.c <<-\END
	volatile char tagged_script_dir[sizeof(SCRIPT_DIR_TAG) + 4096] = {
	  SCRIPT_DIR_TAG "/usr/share/zsh/5.8/scripts"
	};
	volatile char tagged_fpath_dir[sizeof(FPATH_DIR_TAG) + 4096] = {
	  FPATH_DIR_TAG "/usr/share/zsh/5.8/functions"
	};
	volatile char tagged_terminfo_dir[sizeof(TERMINFO_DIR_TAG) + 4096] = {
	  TERMINFO_DIR_TAG "/usr/share/terminfo"
	};

	extern int tgetent_with_env(char *termbuf, char *term) {
	  const char *orig;
	  const char *patched;
	  int res;
	  orig = getenv("TERMINFO_DIRS");
	  patched = orig ? tricat(orig, ":", TERMINFO_DIR) : TERMINFO_DIR;
	  setenv("TERMINFO_DIRS", patched, 1);  /* ignore ENOMEM */
	  res = tgetent(termbuf, term);
	  if (orig) {
	    zsfree((char *)patched);
	    setenv("TERMINFO_DIRS", orig, 1);  /* ignore ENOMEM */
	  } else {
	    unsetenv("TERMINFO_DIRS");
	  }
	  return res;
	}
	END

cat >zshpaths.h <<-\END
	#define MODULE_DIR "/dev/null"

	#define SCRIPT_DIR_TAG ":@ZSH_BIN_MAGIC@:script:"
	#define FPATH_DIR_TAG ":@ZSH_BIN_MAGIC@:fpath:"
	#define TERMINFO_DIR_TAG ":@ZSH_BIN_MAGIC@:terminfo:"

	extern volatile char tagged_script_dir[sizeof(SCRIPT_DIR_TAG) + 4096];
	extern volatile char tagged_fpath_dir[sizeof(FPATH_DIR_TAG) + 4096];
	extern volatile char tagged_terminfo_dir[sizeof(TERMINFO_DIR_TAG) + 4096];

	#define SCRIPT_DIR ((const char *)(tagged_script_dir + sizeof(SCRIPT_DIR_TAG) - 1))
	#define FPATH_DIR ((const char *)(tagged_fpath_dir + sizeof(FPATH_DIR_TAG) - 1))
	#define TERMINFO_DIR ((const char *)(tagged_terminfo_dir + sizeof(TERMINFO_DIR_TAG) - 1))

	extern int tgetent_with_env(char *, char *);
	END

sed_i "s/@ZSH_BIN_MAGIC@/$magic/g" zshpaths.h

make -j "$cpus" install
strip -s /"$name"/bin/zsh
rm /"$name"/bin/zsh-5.8

if [ -d /usr/share/terminfo ]; then
  cp -r /usr/share/terminfo /"$name"/share/
else
  cp /usr/local/share/misc/terminfo.db /"$name"/share/
fi

cat >/"$name"/share/zsh/5.8/scripts/relocate <<-\END
	#!/bin/sh

	set -ue

	magic=@ZSH_BIN_MAGIC@
	fpath_pos=@ZSH_BIN_FPATH_POS@
	script_pos=@ZSH_BIN_SCRIPT_POS@
	terminfo_pos=@ZSH_BIN_TERMINFO_POS@

	if [ $# -gt 2 ]; then
	  >&2 echo 'usage: relocate [/path/to/root-dir] [/path/to/zsh]'
	  exit 1
	fi

	if [ $# -ge 1 ]; then
	  root_dir=$(readlink -f -- "$1")
	else
	  self_dir=$(dirname -- "$0")
	  root_dir=$(readlink -f -- "$self_dir"/../../../..)
	fi

	if [ $# -ge 2 ]; then
	  zsh=$2
	else
	  self_dir=$(dirname -- "$0")
	  zsh="$self_dir"/../../../../bin/zsh
	fi

	if [ ! -x "$zsh" ]; then
	  >&2 echo "[error] not an executable file: $zsh"
	  exit 1
	fi

	root_dir="${root_dir%/}/"

	# 4096 minus 23 for "share/zsh/5.8/functions"
	if [ ${#root_dir} -gt 4073 ]; then
	  >&2 echo "[error] directory name too long: $root_dir"
	  exit 1
	fi

	if [ -z "${root_dir##*$magic*}" ]; then
	  >&2 echo "[error] cannot relocate to this directory: $root_dir"
	  exit 1
	fi

	cp -pf -- "$zsh" "$zsh".tmp

	patch() {
	  local header_len=$((1 + ${#magic} + 1 + ${#2} + 1))
	  local header
	  if ! header=$(dd if="$zsh" bs=1 skip="$1" count="$header_len" 2>/dev/null); then
	    header=$(dd if="$zsh" bs=1 skip="$1" count="$header_len")
	  fi
	  if [ "$header" != ":$magic:$2:" ]; then
	    >&2 echo "[error] not a relocatable zsh binary: $zsh"
	    exit 1
	  fi

	  local pos=$(($1 + header_len))
	  local dir="${root_dir}$3"
	  local err
	  if ! err=$(dd if=/dev/zero of="$zsh".tmp bs=1 seek="$pos" count=4096 conv=notrunc 2>&1); then
	    >&2 printf '%s\n' "$err"
	    exit 1
	  fi
	  if ! err=$(printf '%s' "$dir" |
	               dd of="$zsh".tmp bs=1 seek="$pos" count=${#dir} conv=notrunc 2>&1); then
	    >&2 printf '%s\n' "$err"
	    exit 1
	  fi
	}

	patch "$fpath_pos"    fpath    share/zsh/5.8/functions
	patch "$script_pos"   script   share/zsh/5.8/scripts
	patch "$terminfo_pos" terminfo share/terminfo

	if ! fpath=$("$zsh".tmp -c 'print -r -- $fpath[1]') ||
	   [ "${fpath#$root_dir}" = "$fpath" ]; then
	  >&2 echo "[error] failed to relocate zsh"
	  exit 1
	fi

	mv -f -- "$zsh".tmp "$zsh"
	END

sed_i "s/@ZSH_BIN_MAGIC@/$magic/g" /"$name"/share/zsh/5.8/scripts/relocate

embed_pos() {
  local cmd='
    bin=$(LC_ALL=C tr -c "[:alnum:]:" " " <$0)
    parts=("${(@ps:$1:)bin}")
    (( $#parts == 2 ))
    print -r -- $#parts[1]'
  local pos
  pos=$(/"$name"/bin/zsh -uec "$cmd" /"$name"/bin/zsh ":$magic:$1:")
  printf '%s' "$pos" | grep -qxE '[0-9]+'
  local upper
  upper=$(printf '%s' "$1" | tr '[a-z]' '[A-Z]')
  sed_i "s/@ZSH_BIN_${upper}_POS@/$pos/g" /"$name"/share/zsh/5.8/scripts/relocate
}

embed_pos fpath
embed_pos script
embed_pos terminfo

chmod +x /"$name"/share/zsh/5.8/scripts/relocate

/"$name"/share/zsh/5.8/scripts/relocate
/"$name"/bin/zsh -ec 'zmodload zsh/zselect; autoload -Uz add-zsh-hook; add-zsh-hook precmd x'
/"$name"/share/zsh/5.8/scripts/relocate /usr

case "$ZSH_BIN_KERNEL" in
  linux)
    deref=--hard-dereference
  ;;
  freebsd|msys*|mingw*|cygwin*)
    deref=
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"
    exit 1
  ;;
esac

tar -C / $deref -pczf "$outdir"/tmp."$name".tar.gz "$name"
mv -f -- "$outdir"/tmp."$name".tar.gz "$outdir"/"$name".tar.gz

cleanup

cat >&2 <<-END
	-------------------------------------------------
	SUCCESS: created ./$name.tar.gz.

	This archive contains statically-linked, hermetic,
	relocatable Zsh 5.8. Installation of Zsh from the archive
	doesn't require libc, terminfo, ncurses or root access.
	As long as the target machine has a compatible CPU and
	kernel, it'll work.

	To install Zsh from the archive to ~/.zsh-bin, copy it to
	the target machine's home directory and run:

	  cd
	  rm -rf ~/.zsh-bin ~/$name
	  tar -xzf ~/$name.tar.gz
	  mv $name ~/.zsh-bin
	  ~/.zsh-bin/share/zsh/5.8/scripts/relocate
	  rm ~/$name.tar.gz

	Now you can invoke ~/.zsh-bin/bin/zsh and it'll just work.
	You'll probably want to add ~/.zsh-bin/bin to PATH for
	convenience.

	If you move or rename ~/.zsh-bin, you'll need to call
	share/zsh/5.8/scripts/relocate/relocate afterwards. See the
	last line in the instructions above.
	END
END
)"

arch=
cpu=
image=

while getopts ':m:c:i:h' opt "$@"; do
  case "$opt" in
    m)  arch=$OPTARG;;
    c)  cpu=$OPTARG;;
    i)  image=$OPTARG;;
    h)  printf '%s\n' "$usage"; exit;;
    \?) >&2 echo "[error] invalid option: $OPTARG"           ; exit 1;;
    :)  >&2 echo "[error] missing required argument: $OPTARG"; exit 1;;
    *)  >&2 echo "[internal error] unhandled option: $opt"   ; exit 1;;
  esac
done

if [ "$OPTIND" -le $# ]; then
  >&2 echo "[error] unexpected positional argument"
  return 1
fi

if [ -z "$arch" ]; then
  arch=$(uname -m)
  arch=$(printf '%s' "$arch" | tr '[A-Z]' '[a-z]')
fi

if [ -z "$cpu" ]; then
  case "$arch" in
    armv7l)         cpu=armv7;;
    aarch64)        cpu=armv8-a;;
    x86_64|amd64)   cpu=x86-64;;
    i386|i586|i686) cpu=$arch;;
    *)
      >&2 echo '[error] unable to infer target CPU architecture'
      >&2 echo 'Please specify explicitly with `-c CPU`.'
      exit 1
    ;;
  esac
fi

kernel=$(uname -s)
kernel=$(printf '%s' "$kernel" | tr '[A-Z]' '[a-z]')

case "$kernel" in
  linux)
    if [ -z "$image" ]; then
      case "$arch" in
        x86_64)         image=alpine:3.9.5;;
        i386|i586|i686) image=i386/alpine:3.9.5;;
        armv7l)         image=arm32v7/alpine:3.9.5;;
        aarch64)        image=arm64v8/alpine:3.9.5;;
        *)
          >&2 echo '[error] unable to infer docker image'
          >&2 echo 'Please specify explicitly with `-i IMAGE`.'
          exit 1
        ;;
      esac
    fi
    if ! command -v docker >/dev/null 2>&1; then
      >&2 echo '[error] docker not found; please install and retry'
      exit 1
    fi
  ;;
  freebsd)
    if [ -n "$image" ]; then
      >&2 echo '[error] docker image (-i) is not supported on freebsd'
      exit 1
    fi
  ;;
  msys_nt-*|mingw32_nt-*|mingw64_nt-*|cygwin_nt-*)
    if ! printf '%s' "$kernel" | grep -Eqx '[^-]+-[0-9]+\.[0-9]+(-.*)?'; then
      >&2 echo '[error] unsupported kernel, sorry!'
      exit 1
    fi
    kernel=$(printf '%s' "$kernel" | sed 's/^\([^-]*-[0-9]*\.[0-9]*\).*/\1/')
    if [ -n "$image" ]; then
      >&2 echo '[error] docker image (-i) is not supported on windows'
      exit 1
    fi
  ;;
  *)
    >&2 echo '[error] unsupported kernel, sorry!'
    exit 1
  ;;
esac

>&2 echo "Building zsh..."
>&2 echo ""
[ -n "$image" ] && >&2 echo "  IMAGE=$image"
>&2 echo "  KERNEL=$kernel"
>&2 echo "  ARCH=$arch"
>&2 echo "  CPU=$cpu"

case "$kernel" in
  linux)
    docker run                    \
      -e ZSH_BIN_KERNEL="$kernel" \
      -e ZSH_BIN_ARCH="$arch"     \
      -e ZSH_BIN_CPU="$cpu"       \
      -v "$PWD":/out              \
      -w /out                     \
      --tty                       \
      --rm                        \
      -- "$image" /bin/sh -uexc "$build"
  ;;
  freebsd|msys*|mingw*|cygwin*)
    ZSH_BIN_KERNEL="$kernel" ZSH_BIN_ARCH="$arch" ZSH_BIN_CPU="$cpu" \
      /bin/sh -uexc "$build"
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $kernel";
    exit 1
  ;;
esac
