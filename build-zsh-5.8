#!/bin/sh
#
# Usage: ./build-zsh-5.8 [-m ARCH] [-c CPU] [-i IMAGE]
#
# Type `./build-zsh-5.8 -h` for help and see
# https://github.com/romkatv/zsh-bin for full documentation.

set -ue

usage="$(cat <<\END
Usage: ./build-zsh-5.8 [-m ARCH] [-c CPU] [-i IMAGE]

Creates an archive containing statically-linked, hermetic,
relocatable Zsh 5.8. Installation of Zsh from the archive
doesn't require libc, terminfo, ncurses or root access.
As long as the target machine has a compatible CPU and
Linux kernel, it'll work.

Options:

  -m ARCH   `uname -m` from the target machine; defaults to `uname -m`
            from the local machine
  -c CPU    generate machine instructions for CPU of this type; this
            value gets passed as -march to gcc; inferred from ARCH
            if not set explicitly
  -i IMAGE  docker image used for building zsh; inferred from ARCH
            if not set explicitly
END
)"

build="$(cat <<\END
outdir=$(pwd)
if command -v mktemp >/dev/null 2>&1; then
  workdir=$(mktemp -d "${TMPDIR:-/tmp}"/zsh-bin.XXXXXXXXXX)
else
  workdir="${TMPDIR:-/tmp}/zsh-bin.$$"
  mkdir -- "$workdir"
fi
workdir=$(readlink -f -- "$workdir")
cleanup() {
  cd /
  rm -rf -- "$workdir"
}
trap cleanup INT QUIT TERM EXIT ILL PIPE

libiconv_version=1.16
icmake_version=9.03.01
yodl_version=4.02.01

libiconv_url=https://ftp.gnu.org/pub/gnu/libiconv/libiconv-$libiconv_version.tar.gz
icmake_url=https://gitlab.com/fbb-git/icmake/-/archive/$icmake_version/icmake-$icmake_version.tar.gz
yodl_url=https://gitlab.com/fbb-git/yodl/-/archive/$yodl_version/yodl-$yodl_version.tar.gz
zsh_url=https://github.com/zsh-users/zsh/archive/zsh-5.8.tar.gz

libiconv_sha256=365dac0b34b4255a0066e8033a8b3db4bdb94b9b57a9dca17ebf2d779139fe935caf51a465d17fd8ae229ec4b926f3f7025264f37243432075e5583925bb77b7
icmake_sha256=2e6228c3bffa7fa145fd3743b1220d96b5730350718b91be96600cb24317e17aa5138282fe2f603d00dadd57d7a832ecff21a570eab0c21426f94d3208a61184
yodl_sha256=59e23bb173786b8806f56bf302dee9d8d971d0d840c609e2b24d9783b5866fca2509be844616318f9a4f302117b3a41f620be5cba09181e7ccdcf0c141402be7
zsh_sha256=2474ccb34b4bd7689b2158ec064d5740ddc4eaf5c785006cb251b793a11433817f81250c63eea46801004563097018090eb6a4b4d2670a648ae8bf698eae53dd

cpus=$(getconf _NPROCESSORS_ONLN) || cpus=$(sysctl -n hw.ncpu) || cpus=8

fetch() {
  local url=$1
  local sha256=$2
  local archive=${url##*/}
  local base=${archive%.tar.gz}
  cd -- "$workdir"
  printf '%s  %s\n' "$sha256" "$archive" >"$base".sha256
  if ! cp -- "$outdir/src/$archive" . 2>/dev/null || ! shasum -b -a 512 -c "$base".sha256; then
    rm -f -- "$archive"
    wget -- "$url"
    shasum -b -a 512 -c "$base".sha256
    mkdir -p -- "$outdir"/src
    cp -f -- "$archive" "$outdir"/src/tmp."$archive"
    mv -f -- "$outdir"/src/tmp."$archive" "$outdir"/src/"$archive"
  fi
  tar -xzf "$archive"
}

case "$ZSH_BIN_KERNEL" in
  linux)
    apk update
    apk add          \
      autoconf       \
      bash           \
      binutils       \
      file           \
      g++            \
      gcc            \
      gdbm-dev       \
      groff          \
      make           \
      man            \
      musl-dev       \
      ncurses        \
      ncurses-dev    \
      ncurses-static \
      pcre-dev       \
      perl-utils     \
      tar            \
      util-linux

      fetch "$libiconv_url" "$libiconv_sha256"
      cd libiconv-"$libiconv_version"
      ./configure                     \
        --prefix=/usr                 \
        --disable-dependency-tracking \
        --enable-static               \
        --disable-shared              \
        --enable-extra-encodings      \
        --disable-rpath               \
        --enable-relocatable
      make -j "$cpus" install
  ;;
  freebsd)
    pkg install -y \
      autoconf     \
      binutils     \
      gcc          \
      groff        \
      libiconv     \
      ncurses      \
      perl         \
      pcre         \
      yodl
  ;;
  msys*|mingw*)
    pacman -Sy --noconfirm \
      autoconf             \
      binutils             \
      gcc                  \
      groff                \
      libiconv-devel       \
      make                 \
      man                  \
      ncurses-devel        \
      perl                 \
      pcre-devel           \
      yodl
  ;;
  cygwin*)
    for cmd in autoconf bash colcrt gcc g++ groff ld make shasum tar wget; do
      if ! command -v "$cmd" >/dev/null 2>&1; then
        >&2 echo "[error] command not found: $cmd"
        exit 1
      fi
    done
    for file in /usr/lib/libiconv.a /usr/lib/libncursesw.a /usr/share/terminfo; do
      if [ ! -e "$file" ]; then
        >&2 echo "[error] not found: $file"
        exit 1
      fi
    done
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"
    exit 1
  ;;
esac

if ! command -v yodl >/dev/null 2>&1; then
  if ! command -v icmake >/dev/null 2>&1; then
    fetch "$icmake_url" "$icmake_sha256"
    cd icmake-"$icmake_version"/icmake
    ./icm_prepare /
    ./icm_bootstrap x
    ./icm_install all
  fi

  fetch "$yodl_url" "$yodl_sha256"
  cd yodl-"$yodl_version"
  mkdir fake-bin
  touch fake-bin/tput
  chmod +x fake-bin/tput
  fake_bin_dir="$(pwd)"/fake-bin
  cd yodl
  PATH="$fake_bin_dir:$PATH" ./build programs
  PATH="$fake_bin_dir:$PATH" ./build macros
  PATH="$fake_bin_dir:$PATH" ./build install programs
  PATH="$fake_bin_dir:$PATH" ./build install macros
fi

fetch "$zsh_url" "$zsh_sha256"
cd zsh-zsh-5.8

name=zsh-5.8-"$ZSH_BIN_KERNEL"-"$ZSH_BIN_ARCH"

case "$ZSH_BIN_KERNEL" in
  linux|freebsd|msys*|mingw*)
    extra='--enable-libs=-lpcre'
  ;;
  cygwin*)
    extra=
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"
    exit 1
  ;;
esac

./Util/preconfig
./configure                             \
  --prefix="$workdir/$name"             \
  --disable-etcdir                      \
  --disable-zshenv                      \
  --disable-zshrc                       \
  --disable-zlogin                      \
  --disable-zprofile                    \
  --disable-zlogout                     \
  --disable-site-fndir                  \
  --disable-site-scriptdir              \
  --enable-cap                          \
  --with-tcsetpgrp                      \
  --disable-dynamic                     \
  --enable-ldflags=-static              \
  --enable-cflags=-march="$ZSH_BIN_CPU" \
  --host="$ZSH_BIN_ARCH"                \
  --enable-custom-patchlevel="$name"    \
  $extra

sed_i() {
  [ $# -gt 1 ]
  local script=$1
  while [ $# != 1 ]; do
    shift
    local file=$1
    sed "$script" "$file" >"$file".tmp
    mv -- "$file".tmp "$file"
  done
}

sed_i 's/link=no/link=static/' config.modules

case "$ZSH_BIN_KERNEL" in
  linux);;
  freebsd)
    sed_i 's/attr.mdd link=static/attr.mdd link=no/' config.modules
    sed_i 's/db_gdbm.mdd link=static/db_gdbm.mdd link=no/' config.modules
  ;;
  msys*|mingw*)
    sed_i 's/db_gdbm.mdd link=static/db_gdbm.mdd link=no/' config.modules
  ;;
  cygwin*)
    sed_i 's/db_gdbm.mdd link=static/db_gdbm.mdd link=no/' config.modules
    sed_i 's/pcre.mdd link=static/pcre.mdd link=no/' config.modules
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"
    exit 1
  ;;
esac

magic=iLWDLaG9dUlsxzEQp10k

sed_i '46i\
#include <math.h>' Src/params.c
sed_i 's|mv -f zshpaths.h.tmp zshpaths.h|cp -f ../zshpaths.h ./|' Src/zsh.mdd
sed_i 's/\(\$(LN_S).*\);/( cd -- $(DESTDIR)$(runhelpdir) \&\& \1; );/' Doc/Makefile.in

sed_i 's/tgetent/tgetent_with_env/g' Src/init.c

cat >>Src/init.c <<-\END
	volatile char tagged_script_dir[sizeof(SCRIPT_DIR_TAG) + 4096] = {
	  SCRIPT_DIR_TAG "/usr/share/zsh/5.8/scripts"
	};
	volatile char tagged_fpath_dir[sizeof(FPATH_DIR_TAG) + 4096] = {
	  FPATH_DIR_TAG "/usr/share/zsh/5.8/functions"
	};
	volatile char tagged_terminfo_dir[sizeof(TERMINFO_DIR_TAG) + 4096] = {
	  TERMINFO_DIR_TAG "/usr/share/terminfo"
	};

	extern int tgetent_with_env(char *termbuf, char *term) {
	  const char *orig;
	  const char *patched;
	  int res;
	  orig = getenv("TERMINFO_DIRS");
	  patched = orig ? tricat(orig, ":", TERMINFO_DIR) : TERMINFO_DIR;
	  setenv("TERMINFO_DIRS", patched, 1);  /* ignore ENOMEM */
	  res = tgetent(termbuf, term);
	  if (orig) {
	    zsfree((char *)patched);
	    setenv("TERMINFO_DIRS", orig, 1);  /* ignore ENOMEM */
	  } else {
	    unsetenv("TERMINFO_DIRS");
	  }
	  return res;
	}
	END

cat >zshpaths.h <<-\END
	#define MODULE_DIR "/dev/null"

	#define SCRIPT_DIR_TAG ":@ZSH_BIN_MAGIC@:script:"
	#define FPATH_DIR_TAG ":@ZSH_BIN_MAGIC@:fpath:"
	#define TERMINFO_DIR_TAG ":@ZSH_BIN_MAGIC@:terminfo:"

	extern volatile char tagged_script_dir[sizeof(SCRIPT_DIR_TAG) + 4096];
	extern volatile char tagged_fpath_dir[sizeof(FPATH_DIR_TAG) + 4096];
	extern volatile char tagged_terminfo_dir[sizeof(TERMINFO_DIR_TAG) + 4096];

	#define SCRIPT_DIR ((const char *)(tagged_script_dir + sizeof(SCRIPT_DIR_TAG) - 1))
	#define FPATH_DIR ((const char *)(tagged_fpath_dir + sizeof(FPATH_DIR_TAG) - 1))
	#define TERMINFO_DIR ((const char *)(tagged_terminfo_dir + sizeof(TERMINFO_DIR_TAG) - 1))

	extern int tgetent_with_env(char *, char *);
	END

sed_i "s/@ZSH_BIN_MAGIC@/$magic/g" zshpaths.h

make -j "$cpus" install
strip -s "$workdir/$name"/bin/zsh
rm "$workdir/$name"/bin/zsh-5.8

if [ -d /usr/share/terminfo ]; then
  cp -r /usr/share/terminfo "$workdir/$name"/share/
else
  cp /usr/local/share/misc/terminfo.db "$workdir/$name"/share/
fi

sed_i 's/local HELPDIR=.*/[[ -n "${HELPDIR:-}" ]] || local HELPDIR="$(<<\\'"$magic"'\
'"$magic"'\
)"/'                                                 \
  "$workdir/$name"/share/zsh/5.8/functions/run-help  \
  "$workdir/$name"/share/zsh/5.8/functions/_run-help

cat >"$workdir/$name"/share/zsh/5.8/scripts/relocate <<-\END
	#!/bin/sh

	set -ue

	magic='@ZSH_BIN_MAGIC@'
	fpath_pos=@ZSH_BIN_FPATH_POS@
	script_pos=@ZSH_BIN_SCRIPT_POS@
	terminfo_pos=@ZSH_BIN_TERMINFO_POS@

	usage="$(cat <<-\USAGE
		Usage: relocate [-s SRC] [-d DST]

		Modifies hard-coded paths within Zsh residing in directory SRC
		so that they point to directory DST.

		The source directory must exist but the destination directory
		doesn't have to.

		Options:

		  -s SRC  directory where Zsh is currently installed; this is the
		          directory with `bin` and `usr` as subdirectories; if not
		          specified, this directory is automatically derived from
	          path to `relocate`
		  -d DST  directory from which Zsh will be used; this is the
		          directory with `bin` and `usr` as subdirectories; if not
		          specified, this directory is automatically derived from
		          path to `relocate`
		USAGE
	)"

	src=
	dst=

	while getopts ':s:d:h' opt "$@"; do
	  case "$opt" in
	    s)  src=$OPTARG;;
	    d)  dst=$OPTARG;;
	    h)  printf '%s\n' "$usage"; exit;;
	    \?) >&2 echo "[error] invalid option: $OPTARG"           ; exit 1;;
	    :)  >&2 echo "[error] missing required argument: $OPTARG"; exit 1;;
	    *)  >&2 echo "[internal error] unhandled option: $opt"   ; exit 1;;
	  esac
	done

	if [ "$OPTIND" -le $# ]; then
	  >&2 echo "[error] unexpected positional argument"
	  return 1
	fi

	if [ -n "$src" ]; then
	  src=$(readlink -f -- "$src")
	else
	  self_dir=$(dirname -- "$0")
	  src=$(readlink -f -- "$self_dir"/../../../..)
	fi

	if [ -n "$dst" ]; then
	  dst=$(readlink -f -- "$dst")
	else
	  self_dir=$(dirname -- "$0")
	  dst=$(readlink -f -- "$self_dir"/../../../..)
	fi

	if [ ! -d "$src" ]; then
	  >&2 echo "[error] not a directory: $src"
	  exit 1
	fi

	zsh="$src"/bin/zsh
	runhelp="$src"/share/zsh/5.8/functions/run-help
	runhelpcomp="$src"/share/zsh/5.8/functions/_run-help

	if [ ! -x "$zsh" ]; then
	  >&2 echo "[error] not an executable file: $zsh"
	  exit 1
	fi

	if ! grep -qF 'local HELPDIR' -- "$runhelp"; then
	  >&2 echo "[error] cannot relocate zsh from this directory: $src"
	  exit 1
	fi

	if ! grep -qF 'local HELPDIR' -- "$runhelpcomp"; then
	  >&2 echo "[error] cannot relocate zsh from this directory: $src"
	  exit 1
	fi

	dst="${dst%/}/"

	# 4096 minus 23 for "share/zsh/5.8/functions"
	if [ ${#dst} -gt 4073 ]; then
	  >&2 echo "[error] directory name too long: $dst"
	  exit 1
	fi

	if [ -z "${dst##*$magic*}" ]; then
	  >&2 echo "[error] cannot relocate to this directory: $dst"
	  exit 1
	fi

	cp -pf -- "$zsh" "$zsh".tmp

	patch_help() {
	  local data
	  data=$(cat -- "$1")
	  local prefix="${data%%$magic*}"
	  local suffix="${data##*$magic}"
	  if [ "$prefix" = "$data" -o "$suffix" = "$data" ]; then
	    >&2 echo "[error] not a relocatable zsh directory: $src"
	    exit 1
	  fi
	  local dir="$dst"/share/zsh/5.8/help
	  printf '%s\n%s\n%s\n' "$prefix$magic" "$dir" "$magic$suffix" >"$1".tmp
	}

	patch_bin() {
	  local header_len=$((1 + ${#magic} + 1 + ${#2} + 1))
	  local header
	  if ! header=$(dd if="$zsh" bs=1 skip="$1" count="$header_len" 2>/dev/null); then
	    header=$(dd if="$zsh" bs=1 skip="$1" count="$header_len")
	  fi
	  if [ "$header" != ":$magic:$2:" ]; then
	    >&2 echo "[error] not a relocatable zsh binary: $zsh"
	    exit 1
	  fi

	  local pos=$(($1 + header_len))
	  local dir="${dst}$3"
	  local err
	  if ! err=$(dd if=/dev/zero of="$zsh".tmp bs=1 seek="$pos" count=4096 conv=notrunc 2>&1); then
	    >&2 printf '%s\n' "$err"
	    exit 1
	  fi
	  if ! err=$(printf '%s' "$dir" |
	               dd of="$zsh".tmp bs=1 seek="$pos" count=${#dir} conv=notrunc 2>&1); then
	    >&2 printf '%s\n' "$err"
	    exit 1
	  fi
	}

	patch_help "$runhelp"
	patch_help "$runhelpcomp"

	patch_bin "$fpath_pos"    fpath    share/zsh/5.8/functions
	patch_bin "$script_pos"   script   share/zsh/5.8/scripts
	patch_bin "$terminfo_pos" terminfo share/terminfo

	if ! fpath=$("$zsh".tmp -c 'print -r -- $fpath[1]') ||
	   [ "${fpath#$dst}" = "$fpath" ]; then
	  >&2 echo "[error] failed to relocate zsh"
	  exit 1
	fi

	mv -f -- "$zsh".tmp "$zsh"
	mv -f -- "$runhelp".tmp "$runhelp"
	mv -f -- "$runhelpcomp".tmp "$runhelpcomp"
	END

sed_i "s/@ZSH_BIN_MAGIC@/$magic/g" "$workdir/$name"/share/zsh/5.8/scripts/relocate

embed_pos() {
  local cmd='
    bin=$(LC_ALL=C tr -c "[:alnum:]:" " " <$0)
    parts=("${(@ps:$1:)bin}")
    (( $#parts == 2 ))
    print -r -- $#parts[1]'
  local pos
  pos=$("$workdir/$name"/bin/zsh -fuec "$cmd" "$workdir/$name"/bin/zsh ":$magic:$1:")
  printf '%s' "$pos" | grep -qxE '[0-9]+'
  local upper
  upper=$(printf '%s' "$1" | tr '[a-z]' '[A-Z]')
  sed_i "s/@ZSH_BIN_${upper}_POS@/$pos/g" "$workdir/$name"/share/zsh/5.8/scripts/relocate
}

embed_pos fpath
embed_pos script
embed_pos terminfo

chmod +x "$workdir/$name"/share/zsh/5.8/scripts/relocate

"$workdir/$name"/share/zsh/5.8/scripts/relocate
"$workdir/$name"/bin/zsh -fec 'zmodload zsh/stat; autoload -Uz add-zsh-hook; add-zsh-hook precmd x'
"$workdir/$name"/share/zsh/5.8/scripts/relocate -d /usr

case "$ZSH_BIN_KERNEL" in
  linux)
    deref=--hard-dereference
  ;;
  freebsd|msys*|mingw*|cygwin*)
    deref=
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $ZSH_BIN_KERNEL"
    exit 1
  ;;
esac

tar -C "$workdir" $deref -pczf "$outdir"/tmp."$name".tar.gz "$name"
mv -f -- "$outdir"/tmp."$name".tar.gz "$outdir"/"$name".tar.gz

cleanup

cat >&2 <<-END
	-------------------------------------------------
	SUCCESS: created ./$name.tar.gz.

	This archive contains statically-linked, hermetic,
	relocatable Zsh 5.8. Installation of Zsh from the archive
	doesn't require libc, terminfo, ncurses or root access.
	As long as the target machine has a compatible CPU and
	kernel, it'll work.

	To install Zsh from the archive to ~/.zsh-bin, copy it to
	the target machine's home directory and run:

	  cd
	  rm -rf ~/.zsh-bin ~/$name
	  tar -xzf ~/$name.tar.gz
	  mv $name ~/.zsh-bin
	  ~/.zsh-bin/share/zsh/5.8/scripts/relocate
	  rm ~/$name.tar.gz

	Now you can invoke ~/.zsh-bin/bin/zsh and it'll just work.
	You'll probably want to add ~/.zsh-bin/bin to PATH for
	convenience.

	If you move or rename ~/.zsh-bin, you'll need to call
	share/zsh/5.8/scripts/relocate/relocate afterwards. See the
	last line in the instructions above.
	END
END
)"

arch=
cpu=
image=

while getopts ':m:c:i:h' opt "$@"; do
  case "$opt" in
    m)  arch=$OPTARG;;
    c)  cpu=$OPTARG;;
    i)  image=$OPTARG;;
    h)  printf '%s\n' "$usage"; exit;;
    \?) >&2 echo "[error] invalid option: $OPTARG"           ; exit 1;;
    :)  >&2 echo "[error] missing required argument: $OPTARG"; exit 1;;
    *)  >&2 echo "[internal error] unhandled option: $opt"   ; exit 1;;
  esac
done

if [ "$OPTIND" -le $# ]; then
  >&2 echo "[error] unexpected positional argument"
  return 1
fi

if [ -z "$arch" ]; then
  arch=$(uname -m)
  arch=$(printf '%s' "$arch" | tr '[A-Z]' '[a-z]')
fi

if [ -z "$cpu" ]; then
  case "$arch" in
    armv7l)         cpu=armv7;;
    aarch64)        cpu=armv8-a;;
    x86_64|amd64)   cpu=x86-64;;
    i386|i586|i686) cpu=$arch;;
    *)
      >&2 echo '[error] unable to infer target CPU architecture'
      >&2 echo 'Please specify explicitly with `-c CPU`.'
      exit 1
    ;;
  esac
fi

kernel=$(uname -s)
kernel=$(printf '%s' "$kernel" | tr '[A-Z]' '[a-z]')

case "$kernel" in
  linux)
    if [ -z "$image" ]; then
      case "$arch" in
        x86_64)         image=alpine:3.9.5;;
        i386|i586|i686) image=i386/alpine:3.9.5;;
        armv7l)         image=arm32v7/alpine:3.9.5;;
        aarch64)        image=arm64v8/alpine:3.9.5;;
        *)
          >&2 echo '[error] unable to infer docker image'
          >&2 echo 'Please specify explicitly with `-i IMAGE`.'
          exit 1
        ;;
      esac
    fi
    if ! command -v docker >/dev/null 2>&1; then
      >&2 echo '[error] docker not found; please install and retry'
      exit 1
    fi
  ;;
  freebsd)
    if [ -n "$image" ]; then
      >&2 echo '[error] docker image (-i) is not supported on freebsd'
      exit 1
    fi
  ;;
  msys_nt-*|mingw32_nt-*|mingw64_nt-*|cygwin_nt-*)
    if ! printf '%s' "$kernel" | grep -Eqx '[^-]+-[0-9]+\.[0-9]+(-.*)?'; then
      >&2 echo '[error] unsupported kernel, sorry!'
      exit 1
    fi
    kernel=$(printf '%s' "$kernel" | sed 's/^\([^-]*-[0-9]*\.[0-9]*\).*/\1/')
    if [ -n "$image" ]; then
      >&2 echo '[error] docker image (-i) is not supported on windows'
      exit 1
    fi
  ;;
  *)
    >&2 echo '[error] unsupported kernel, sorry!'
    exit 1
  ;;
esac

>&2 echo "Building zsh..."
>&2 echo ""
[ -n "$image" ] && >&2 echo "  IMAGE=$image"
>&2 echo "  KERNEL=$kernel"
>&2 echo "  ARCH=$arch"
>&2 echo "  CPU=$cpu"

case "$kernel" in
  linux)
    docker run                    \
      -e ZSH_BIN_KERNEL="$kernel" \
      -e ZSH_BIN_ARCH="$arch"     \
      -e ZSH_BIN_CPU="$cpu"       \
      -v "$PWD":/out              \
      -w /out                     \
      --tty                       \
      --rm                        \
      -- "$image" /bin/sh -uexc "$build"
  ;;
  freebsd|msys*|mingw*|cygwin*)
    ZSH_BIN_KERNEL="$kernel" ZSH_BIN_ARCH="$arch" ZSH_BIN_CPU="$cpu" \
      /bin/sh -uexc "$build"
  ;;
  *)
    >&2 echo "[internal error] unhandled kernel: $kernel";
    exit 1
  ;;
esac
